'''
Generate plots from an SQLite database generated by load.py
'''
import argparse
import pathlib

import plotly.graph_objects as go

from load import Database


def posts_freq_time(db: Database, term: str = None):
    if term:
        term = f'%{term}%'
        db.c.execute('SELECT created, COUNT(*) FROM posts '
                     'WHERE selftext LIKE ? OR title LIKE ? '
                     'GROUP BY created ORDER BY created ASC', (term, term))
    else:
        db.c.execute('SELECT created, COUNT(*) FROM posts'
                     'GROUP BY created ORDER BY created ASC')
    return db.c.fetchall()


def comments_freq_time(db: Database, term: str = None):
    if term:
        term = f'%{term}%'
        db.c.execute('SELECT created, COUNT(*) FROM comments '
                     'WHERE body LIKE ? GROUP BY created '
                     'ORDER BY created ASC', (term,))
    else:
        db.c.execute('SELECT created, COUNT(*) FROM comments '
                     'GROUP BY created ORDER BY created ASC')
    return db.c.fetchall()


def plot_layout(measured: str, query: str, **attrs):
    return {
        'title': f'{measured.title()} referencing SLV, GME in /r/wsb',
        'xaxis': {
            'title': 'Time (one-hour intervals, EST)',
            'range': ['2021-01-29T00:00:00', '2021-02-01T15:00:00']
        },
        'yaxis': {'title': f'# {measured.lower()} referencing {query.lower()}'},
        'legend_title': query.title(),
        **attrs
    }


def slv_gme_comments(db: Database, outpath: str):
    gme_x, gme_y = zip(*comments_freq_time(db, 'GME'))
    slv_x, slv_y = zip(*comments_freq_time(db, 'SLV'))
    fig = go.Figure(data=go.Bar(x=gme_x, y=gme_y, name='GME'))
    fig.add_bar(x=slv_x, y=slv_y, name='SLV')
    fig.update_layout(plot_layout('comments', 'symbol'))
    fig.write_image(outpath)


def slv_gme_posts(db: Database, outpath: str):
    gme_x, gme_y = zip(*posts_freq_time(db, 'GME'))
    slv_x, slv_y = zip(*posts_freq_time(db, 'SLV'))
    fig = go.Figure(data=go.Bar(x=gme_x, y=gme_y, name='GME'))
    fig.add_bar(x=slv_x, y=slv_y, name='SLV')
    fig.update_layout(plot_layout('posts', 'term'))
    fig.write_image(outpath)


def silver_gamestop_posts(db: Database, outpath: str):
    gme_x, gme_y = zip(*posts_freq_time(db, 'silver'))
    slv_x, slv_y = zip(*posts_freq_time(db, 'gamestop'))
    fig = go.Figure(data=go.Bar(x=gme_x, y=gme_y, name='"silver"'))
    fig.add_bar(x=slv_x, y=slv_y, name='"gamestop"')
    fig.update_layout(plot_layout('posts', 'term'))
    fig.write_image(outpath)


def silver_gme_comments(db: Database, outpath: str):
    gme_x, gme_y = zip(*comments_freq_time(db, 'GME'))
    fig = go.Figure(data=go.Bar(x=gme_x, y=gme_y, name='"GME"'))

    slv_x, slv_y = zip(*comments_freq_time(db, 'SLV'))
    fig.add_bar(x=slv_x, y=slv_y, name='"SLV"')

    gamestop_x, gamestop_y = zip(*comments_freq_time(db, 'gamestop'))
    fig.add_bar(x=gamestop_x, y=gamestop_y, name='"Gamestop"')

    silver_x, silver_y = zip(*comments_freq_time(db, 'silver'))
    fig.add_bar(x=silver_x, y=silver_y, name='"Silver"')

    dlr_gme_x, dlr_gme_y = zip(*comments_freq_time(db, '$GME'))
    fig.add_bar(x=dlr_gme_x, y=dlr_gme_y, name='"$GME"')

    dlr_silver_x, dlr_silver_y = zip(*comments_freq_time(db, '$SLV'))
    fig.add_bar(x=dlr_silver_x, y=dlr_silver_y, name='"$SLV"')

    layout = plot_layout('comments', 'term')
    fig.update_layout(**layout)
    fig.write_image(outpath)


def generate_all_plots(db: Database, outpath: str):
    outdir = pathlib.Path(outpath)
    outdir.mkdir(parents=True, exist_ok=True)
    for name, func in dispatch.items():
        if name == 'all':
            pass
        else:
            fname = outdir / f'{name}.png'
            func(db, fname.as_posix())


dispatch = {
    'all': generate_all_plots,
    'slv_gme_comments': slv_gme_comments,
    'slv_gme_posts': slv_gme_posts,
    'silver_gme_comments': silver_gme_comments,
    'silver_gamestop_posts': silver_gamestop_posts
}


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('db_path')
    parser.add_argument('metric', choices=dispatch)
    parser.add_argument('output', help='foo.png')
    arguments = parser.parse_args()

    db = Database(arguments.db_path)
    dispatch[arguments.metric](db, arguments.output)
